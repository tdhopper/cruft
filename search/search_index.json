{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trending Contributors Read Latest Documentation - Browse GitHub Code Repository cruft allows you to maintain all the necessary boilerplate for packaging and building projects separate from the code you intentionally write. Fully compatible with existing Cookiecutter templates. Creating new projects from templates using cruft is easy: And, so is updating them as the template changes overtime: Many project template utilities exist that automate the copying and pasting of code to create new projects. This seems great! However, once created, most leave you with that copy-and-pasted code to manage through the life of your project. cruft is different. It automates the creation of new projects like the others, but then it also helps you to manage the boilerplate through the life of the project. cruft makes sure your code stays in-sync with the template it came from for you. Key Features: Cookiecutter Compatible : cruft utilizes Cookiecutter as its template expansion engine. Meaning it retains full compatibility with all existing Cookiecutter templates. Template Validation : cruft can quickly validate whether or not a project is using the latest version of a template using cruft check . This check can easily be added to CI pipelines to ensure your projects stay in-sync. Automatic Template Updates : cruft automates the process of updating code to match the latest version of a template, making it easy to utilize template improvements across many projects. Installation: To get started - install cruft using a Python package manager: pip3 install cruft OR poetry add cruft OR pipenv install cruft Creating a New Project: To create a new project using cruft run cruft create PROJECT_URL from the command line. For example: cruft create https://github.com/timothycrosley/cookiecutter-python/ cruft will then ask you any necessary questions to create your new project. It will use your answers to expand the provided template, and then return the directory it placed the expanded project. Behind the scenes, cruft uses Cookiecutter to do the project expansion. The only difference in the resulting output is a .cruft.json file that contains the git hash of the template used as well as the parameters specified. Updating a Project To update an existing project, that was created using cruft, run cruft update in the root of the project. If there are any updates, cruft will have you review them before applying. If you accept the changes cruft will apply them to your project and update the .cruft.json file for you. Tip Sometimes certain files just aren't good fits for updating. Such as test cases or __init__ files. You can tell cruft to always skip updating these files on a project by project basis by added them to a skip section within your .cruft.json file: { \"template\": \"https://github.com/timothycrosley/cookiecutter-python\", \"commit\": \"8a65a360d51250221193ed0ec5ed292e72b32b0b\", \"skip\": [ \"cruft/__init__.py\", \"tests\" ], ... } Or, if you have toml installed, you can add skip files directly to a tool.cruft section of your pyproject.toml file: [tool.cruft] skip = [\"cruft/__init__.py\", \"tests\"] Checking a Project Checking to see if a project is missing a template update is as easy as running cruft check . If the project is out-of-date an error and exit code 1 will be returned. cruft check can be added to CI pipelines to ensure projects don't unintentionally drift. Linking an Existing Project Have an existing project that you created from a template in the past using Cookiecutter directly? You can link it to the template that was used to create it using: cruft link TEMPLATE_REPOSITORY . For example: cruft link https://github.com/timothycrosley/cookiecutter-python/ You can then specify the last commit of the template the project has been updated to be consistent with, or accept the default of using the latest commit from the template. Why Create cruft? Since I first saw videos of quickly being used to automate Ubuntu application creation, I've had a love/hate relationship with these kinds of tools. I've used them for many projects and certainly seen them lead to productivity improvements. However, I've always felt like they were a double-edged sword. Sure, they would automate away the copying and pasting many would do to create projects. However, by doing so, they encouraged more code to be copied and pasted! Then, over time, you could easily be left with hundreds of projects that contained copy-and-pasted code with no way to easy way to update them. I created cruft to be a tool that recognized that balance between project creation and maintenance and provided mechanisms to keep built projects up-to-date. I hope you too find cruft useful! ~Timothy Crosley","title":"Home"},{"location":"#trending-contributors","text":"Read Latest Documentation - Browse GitHub Code Repository cruft allows you to maintain all the necessary boilerplate for packaging and building projects separate from the code you intentionally write. Fully compatible with existing Cookiecutter templates. Creating new projects from templates using cruft is easy: And, so is updating them as the template changes overtime: Many project template utilities exist that automate the copying and pasting of code to create new projects. This seems great! However, once created, most leave you with that copy-and-pasted code to manage through the life of your project. cruft is different. It automates the creation of new projects like the others, but then it also helps you to manage the boilerplate through the life of the project. cruft makes sure your code stays in-sync with the template it came from for you.","title":"Trending Contributors"},{"location":"#key-features","text":"Cookiecutter Compatible : cruft utilizes Cookiecutter as its template expansion engine. Meaning it retains full compatibility with all existing Cookiecutter templates. Template Validation : cruft can quickly validate whether or not a project is using the latest version of a template using cruft check . This check can easily be added to CI pipelines to ensure your projects stay in-sync. Automatic Template Updates : cruft automates the process of updating code to match the latest version of a template, making it easy to utilize template improvements across many projects.","title":"Key Features:"},{"location":"#installation","text":"To get started - install cruft using a Python package manager: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Installation:"},{"location":"#creating-a-new-project","text":"To create a new project using cruft run cruft create PROJECT_URL from the command line. For example: cruft create https://github.com/timothycrosley/cookiecutter-python/ cruft will then ask you any necessary questions to create your new project. It will use your answers to expand the provided template, and then return the directory it placed the expanded project. Behind the scenes, cruft uses Cookiecutter to do the project expansion. The only difference in the resulting output is a .cruft.json file that contains the git hash of the template used as well as the parameters specified.","title":"Creating a New Project:"},{"location":"#updating-a-project","text":"To update an existing project, that was created using cruft, run cruft update in the root of the project. If there are any updates, cruft will have you review them before applying. If you accept the changes cruft will apply them to your project and update the .cruft.json file for you. Tip Sometimes certain files just aren't good fits for updating. Such as test cases or __init__ files. You can tell cruft to always skip updating these files on a project by project basis by added them to a skip section within your .cruft.json file: { \"template\": \"https://github.com/timothycrosley/cookiecutter-python\", \"commit\": \"8a65a360d51250221193ed0ec5ed292e72b32b0b\", \"skip\": [ \"cruft/__init__.py\", \"tests\" ], ... } Or, if you have toml installed, you can add skip files directly to a tool.cruft section of your pyproject.toml file: [tool.cruft] skip = [\"cruft/__init__.py\", \"tests\"]","title":"Updating a Project"},{"location":"#checking-a-project","text":"Checking to see if a project is missing a template update is as easy as running cruft check . If the project is out-of-date an error and exit code 1 will be returned. cruft check can be added to CI pipelines to ensure projects don't unintentionally drift.","title":"Checking a Project"},{"location":"#linking-an-existing-project","text":"Have an existing project that you created from a template in the past using Cookiecutter directly? You can link it to the template that was used to create it using: cruft link TEMPLATE_REPOSITORY . For example: cruft link https://github.com/timothycrosley/cookiecutter-python/ You can then specify the last commit of the template the project has been updated to be consistent with, or accept the default of using the latest commit from the template.","title":"Linking an Existing Project"},{"location":"#why-create-cruft","text":"Since I first saw videos of quickly being used to automate Ubuntu application creation, I've had a love/hate relationship with these kinds of tools. I've used them for many projects and certainly seen them lead to productivity improvements. However, I've always felt like they were a double-edged sword. Sure, they would automate away the copying and pasting many would do to create projects. However, by doing so, they encouraged more code to be copied and pasted! Then, over time, you could easily be left with hundreds of projects that contained copy-and-pasted code with no way to easy way to update them. I created cruft to be a tool that recognized that balance between project creation and maintenance and provided mechanisms to keep built projects up-to-date. I hope you too find cruft useful! ~Timothy Crosley","title":"Why Create cruft?"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft Changelog 1.4.0 - 11 August 2020 Fixed issue #21 : Improve messaging when diff is empty. Implemented #15 : Allow piping diff to an external utility. Implemented #33 : When possible, use git apply instead of patch . 1.3.0 - 9 August 2020 Fixed issue #8 : Fall back to no-backup if patch doesn't support --merge. Fixed issue #11 : Config file flag --config_file broken. Implemented #24 : Allow cruft update to specify a branch of the cookiecutter repo. Implemented #10 : Provide a mechanism to choose template version. Internal: - Refactored api module into a collection of smaller better scoped modules. 1.2.0 - 7 August 2020 Fixed issue #26 : Support for Directory as there are multiple templates in single repo Fixed issue #18 & #13 : Commands fail with OSError randomly on windows 1.1.2 - 3 October 2019 Fixed Issue #3 : Patch failed to apply. Updated to use pathlib. Improved pyproject.toml skip_files, avoiding duplication into .cruft.json file. 1.1.1 - 25 September 2019 Added optional support for reading skip options from pyproject.toml . 1.1.0 - 24 September 2019 Added link command to link existing repositories to the Cookiecutter template that created them. Added skip option to .cruft.json file allowing template updates to be skipped per a repository. Improved patch applying from template updates. Added an interactive option on the update command to skip an individual update, while marking a repository as up-to-date. 1.0.0 - 23 September 2019 Initial API stable release.","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#140-11-august-2020","text":"Fixed issue #21 : Improve messaging when diff is empty. Implemented #15 : Allow piping diff to an external utility. Implemented #33 : When possible, use git apply instead of patch .","title":"1.4.0 - 11 August 2020"},{"location":"CHANGELOG/#130-9-august-2020","text":"Fixed issue #8 : Fall back to no-backup if patch doesn't support --merge. Fixed issue #11 : Config file flag --config_file broken. Implemented #24 : Allow cruft update to specify a branch of the cookiecutter repo. Implemented #10 : Provide a mechanism to choose template version. Internal: - Refactored api module into a collection of smaller better scoped modules.","title":"1.3.0 - 9 August 2020"},{"location":"CHANGELOG/#120-7-august-2020","text":"Fixed issue #26 : Support for Directory as there are multiple templates in single repo Fixed issue #18 & #13 : Commands fail with OSError randomly on windows","title":"1.2.0 - 7 August 2020"},{"location":"CHANGELOG/#112-3-october-2019","text":"Fixed Issue #3 : Patch failed to apply. Updated to use pathlib. Improved pyproject.toml skip_files, avoiding duplication into .cruft.json file.","title":"1.1.2 - 3 October 2019"},{"location":"CHANGELOG/#111-25-september-2019","text":"Added optional support for reading skip options from pyproject.toml .","title":"1.1.1 - 25 September 2019"},{"location":"CHANGELOG/#110-24-september-2019","text":"Added link command to link existing repositories to the Cookiecutter template that created them. Added skip option to .cruft.json file allowing template updates to be skipped per a repository. Improved patch applying from template updates. Added an interactive option on the update command to skip an individual update, while marking a repository as up-to-date.","title":"1.1.0 - 24 September 2019"},{"location":"CHANGELOG/#100-23-september-2019","text":"Initial API stable release.","title":"1.0.0 - 23 September 2019"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to cruft Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting cruft set up for local development The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-cruft","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to cruft"},{"location":"docs/contributing/1.-contributing-guide/#getting-cruft-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install","title":"Getting cruft set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Sambhav Kothari ( @samj1912 ) Timothy Crosley ( @timothycrosley ) Special Mentions Peter Olson ( @peter200lx ) for coming up with the main implementation idea behind cruft. Notable Bug Reporters - Code Contributors Peter Olson ( @peter200lx ) Medhat Assaad ( @massaad ) Appunni M ( @appunni-dishq ) Documenters - A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Sambhav Kothari ( @samj1912 ) Timothy Crosley ( @timothycrosley )","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#special-mentions","text":"Peter Olson ( @peter200lx ) for coming up with the main implementation idea behind cruft.","title":"Special Mentions"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"Peter Olson ( @peter200lx ) Medhat Assaad ( @massaad ) Appunni M ( @appunni-dishq )","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"reference/cruft/","text":"Module cruft cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._commands import check , create , link , update from cruft._version import __version__ __all__ = [ \"create\" , \"check\" , \"update\" , \"link\" , \"__version__\" ] Sub-modules cruft.exceptions Variables __version__ Functions check def check ( project_dir : pathlib . Path = PosixPath ( '.' ), checkout : Union [ str , NoneType ] = None ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. Examples: check ( ) View Source @example () def check ( project_dir : Path = Path ( \".\" ), checkout : Optional [ str ] = None ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project.\"\"\" cruft_file = get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) with RobustTemporaryDirectory () as cookiecutter_template_dir : repo = get_cookiecutter_repo ( cruft_state [ \"template\" ] , cookiecutter_template_dir , checkout ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ] ) : typer . secho ( \"SUCCESS: Good work! Project's cruft is up to date and as clean as possible :).\" , fg = typer . colors . GREEN , ) return True typer . secho ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" , fg = typer . colors . RED , ) return False create def create ( template_git_url : str , output_dir : pathlib . Path = PosixPath ( '.' ), config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , no_input : bool = True , directory : Union [ str , NoneType ] = None , checkout : Union [ str , NoneType ] = None , overwrite_if_exists : bool = False ) -> pathlib . Path Expand a Git based Cookiecutter template into a new project on disk. Examples: create( 'https://github.com/timothycrosley/cookiecutter-python/' ) View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def create ( template_git_url : str , output_dir : Path = Path ( \".\" ), config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , no_input : bool = True , directory : Optional [ str ] = None , checkout : Optional [ str ] = None , overwrite_if_exists : bool = False , ) -> Path : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" with RobustTemporaryDirectory () as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) repo = get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir , checkout ) last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory context = generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) project_dir = Path ( generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = str ( output_dir ), ) ) # After generating the project - save the cruft state # into the cruft file . ( project_dir / \".cruft.json\" ). write_text ( json_dumps ( { \"template\" : template_git_url , \"commit\" : last_commit , \"context\" : context , \"directory\" : directory , } ) ) return project_dir link def link ( template_git_url : str , project_dir : pathlib . Path = PosixPath ( '.' ), use_commit : Union [ str , NoneType ] = None , no_input : bool = True , config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , directory : Union [ str , NoneType ] = None ) -> bool Links an existing project created from a template, to the template it was created from. Examples: link( 'https://github.com/timothycrosley/cookiecutter-python/' ) View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def link ( template_git_url : str , project_dir : Path = Path ( \".\" ), use_commit : Optional [ str ] = None , no_input : bool = True , config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , directory : Optional [ str ] = None , ) -> bool : \"\"\"Links an existing project created from a template, to the template it was created from.\"\"\" cruft_file = get_cruft_file ( project_dir , exists = False ) with RobustTemporaryDirectory () as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) repo = get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory context = generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) if not use_commit : if no_input : use_commit = last_commit else : typer . echo ( f \"The latest commit to the template is {last_commit}\" ) typer . echo ( \"Press enter to link against this commit or provide an alternative commit.\" ) use_commit = typer . prompt ( \"Link to template at commit\" , default = last_commit ) cruft_file . write_text ( json_dumps ( { \"template\" : template_git_url , \"commit\" : use_commit , \"context\" : context , \"directory\" : directory , } ) ) return True update def update ( project_dir : pathlib . Path = PosixPath ( '.' ), cookiecutter_input : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Union [ str , NoneType ] = None ) -> bool Update specified project's cruft to the latest and greatest release. Examples: update ( ) update( skip_apply_ask=False ) View Source @example ( skip_apply_ask = False ) @example () def update ( project_dir : Path = Path ( \".\" ), cookiecutter_input : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Optional [ str ] = None , ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" pyproject_file = project_dir / \"pyproject.toml\" cruft_file = get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) with RobustTemporaryDirectory () as compare_directory_str : # Initial setup compare_directory = Path ( compare_directory_str ) template_dir = compare_directory / \"template\" repo = get_cookiecutter_repo ( cruft_state [ \"template\" ] , template_dir , checkout ) directory = cruft_state . get ( \"directory\" , None ) if directory : template_dir = template_dir / directory last_commit = repo . head . object . hexsha # Bail early if the repo is already up to date if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ] ) : typer . secho ( \"Nothing to do, project's cruft is already up to date!\" , fg = typer . colors . GREEN ) return True # Generate clean outputs via the cookiecutter # from the current cruft state commit of the cookiectter and the updated # cookiecutter . old_main_directory , new_main_directory , new_context = _generate_project_updates ( compare_directory , cruft_state , template_dir , cookiecutter_input , repo ) # Remove any files from the generated versions that we are supposed # to skip before generating the diff and applying updates _remove_skip_files ( cruft_state , pyproject_file , old_main_directory , new_main_directory ) # Given the two versions of the cookiecutter outputs based # on the current project ' s context we calculate the diff and # apply the updates to the current project . if _apply_project_updates ( old_main_directory , new_main_directory , project_dir , skip_update , skip_apply_ask ) : # Update the cruft state and dump the new state # to the cruft file cruft_state [ \"commit\" ] = last_commit cruft_state [ \"context\" ] = new_context cruft_state [ \"directory\" ] = directory cruft_file . write_text ( json_dumps ( cruft_state )) return True","title":"Index"},{"location":"reference/cruft/#module-cruft","text":"cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._commands import check , create , link , update from cruft._version import __version__ __all__ = [ \"create\" , \"check\" , \"update\" , \"link\" , \"__version__\" ]","title":"Module cruft"},{"location":"reference/cruft/#sub-modules","text":"cruft.exceptions","title":"Sub-modules"},{"location":"reference/cruft/#variables","text":"__version__","title":"Variables"},{"location":"reference/cruft/#functions","text":"","title":"Functions"},{"location":"reference/cruft/#check","text":"def check ( project_dir : pathlib . Path = PosixPath ( '.' ), checkout : Union [ str , NoneType ] = None ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. Examples: check ( ) View Source @example () def check ( project_dir : Path = Path ( \".\" ), checkout : Optional [ str ] = None ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project.\"\"\" cruft_file = get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) with RobustTemporaryDirectory () as cookiecutter_template_dir : repo = get_cookiecutter_repo ( cruft_state [ \"template\" ] , cookiecutter_template_dir , checkout ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ] ) : typer . secho ( \"SUCCESS: Good work! Project's cruft is up to date and as clean as possible :).\" , fg = typer . colors . GREEN , ) return True typer . secho ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" , fg = typer . colors . RED , ) return False","title":"check"},{"location":"reference/cruft/#create","text":"def create ( template_git_url : str , output_dir : pathlib . Path = PosixPath ( '.' ), config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , no_input : bool = True , directory : Union [ str , NoneType ] = None , checkout : Union [ str , NoneType ] = None , overwrite_if_exists : bool = False ) -> pathlib . Path Expand a Git based Cookiecutter template into a new project on disk. Examples: create( 'https://github.com/timothycrosley/cookiecutter-python/' ) View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def create ( template_git_url : str , output_dir : Path = Path ( \".\" ), config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , no_input : bool = True , directory : Optional [ str ] = None , checkout : Optional [ str ] = None , overwrite_if_exists : bool = False , ) -> Path : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" with RobustTemporaryDirectory () as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) repo = get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir , checkout ) last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory context = generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) project_dir = Path ( generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = str ( output_dir ), ) ) # After generating the project - save the cruft state # into the cruft file . ( project_dir / \".cruft.json\" ). write_text ( json_dumps ( { \"template\" : template_git_url , \"commit\" : last_commit , \"context\" : context , \"directory\" : directory , } ) ) return project_dir","title":"create"},{"location":"reference/cruft/#link","text":"def link ( template_git_url : str , project_dir : pathlib . Path = PosixPath ( '.' ), use_commit : Union [ str , NoneType ] = None , no_input : bool = True , config_file : Union [ pathlib . Path , NoneType ] = None , default_config : bool = False , extra_context : Union [ Dict [ str , Any ], NoneType ] = None , directory : Union [ str , NoneType ] = None ) -> bool Links an existing project created from a template, to the template it was created from. Examples: link( 'https://github.com/timothycrosley/cookiecutter-python/' ) View Source @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" ) def link ( template_git_url : str , project_dir : Path = Path ( \".\" ), use_commit : Optional [ str ] = None , no_input : bool = True , config_file : Optional [ Path ] = None , default_config : bool = False , extra_context : Optional [ Dict[str, Any ] ] = None , directory : Optional [ str ] = None , ) -> bool : \"\"\"Links an existing project created from a template, to the template it was created from.\"\"\" cruft_file = get_cruft_file ( project_dir , exists = False ) with RobustTemporaryDirectory () as cookiecutter_template_dir_str : cookiecutter_template_dir = Path ( cookiecutter_template_dir_str ) repo = get_cookiecutter_repo ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if directory : cookiecutter_template_dir = cookiecutter_template_dir / directory context = generate_cookiecutter_context ( template_git_url , cookiecutter_template_dir , config_file , default_config , extra_context , no_input , ) if not use_commit : if no_input : use_commit = last_commit else : typer . echo ( f \"The latest commit to the template is {last_commit}\" ) typer . echo ( \"Press enter to link against this commit or provide an alternative commit.\" ) use_commit = typer . prompt ( \"Link to template at commit\" , default = last_commit ) cruft_file . write_text ( json_dumps ( { \"template\" : template_git_url , \"commit\" : use_commit , \"context\" : context , \"directory\" : directory , } ) ) return True","title":"link"},{"location":"reference/cruft/#update","text":"def update ( project_dir : pathlib . Path = PosixPath ( '.' ), cookiecutter_input : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Union [ str , NoneType ] = None ) -> bool Update specified project's cruft to the latest and greatest release. Examples: update ( ) update( skip_apply_ask=False ) View Source @example ( skip_apply_ask = False ) @example () def update ( project_dir : Path = Path ( \".\" ), cookiecutter_input : bool = False , skip_apply_ask : bool = True , skip_update : bool = False , checkout : Optional [ str ] = None , ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" pyproject_file = project_dir / \"pyproject.toml\" cruft_file = get_cruft_file ( project_dir ) cruft_state = json . loads ( cruft_file . read_text ()) with RobustTemporaryDirectory () as compare_directory_str : # Initial setup compare_directory = Path ( compare_directory_str ) template_dir = compare_directory / \"template\" repo = get_cookiecutter_repo ( cruft_state [ \"template\" ] , template_dir , checkout ) directory = cruft_state . get ( \"directory\" , None ) if directory : template_dir = template_dir / directory last_commit = repo . head . object . hexsha # Bail early if the repo is already up to date if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ] ) : typer . secho ( \"Nothing to do, project's cruft is already up to date!\" , fg = typer . colors . GREEN ) return True # Generate clean outputs via the cookiecutter # from the current cruft state commit of the cookiectter and the updated # cookiecutter . old_main_directory , new_main_directory , new_context = _generate_project_updates ( compare_directory , cruft_state , template_dir , cookiecutter_input , repo ) # Remove any files from the generated versions that we are supposed # to skip before generating the diff and applying updates _remove_skip_files ( cruft_state , pyproject_file , old_main_directory , new_main_directory ) # Given the two versions of the cookiecutter outputs based # on the current project ' s context we calculate the diff and # apply the updates to the current project . if _apply_project_updates ( old_main_directory , new_main_directory , project_dir , skip_update , skip_apply_ask ) : # Update the cruft state and dump the new state # to the cruft file cruft_state [ \"commit\" ] = last_commit cruft_state [ \"context\" ] = new_context cruft_state [ \"directory\" ] = directory cruft_file . write_text ( json_dumps ( cruft_state )) return True","title":"update"},{"location":"reference/cruft/exceptions/","text":"Module cruft.exceptions Contains all custom exceptions raised by cruft. View Source \"\"\"Contains all custom exceptions raised by cruft.\"\"\" from pathlib import Path from typing import Union from click import ClickException class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\" class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location : Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super () . __init__ ( f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo : str ): super () . __init__ ( f \"{cookiecutter_repo} is not a valid Cookiecutter git repository!\" ) self . cookiecutter_repo = cookiecutter_repo Classes CruftAlreadyPresent class CruftAlreadyPresent ( file_location : Union [ str , pathlib . Path ] ) Raised when there is an attempt to create a new .cruft.json file but one already exists. View Source class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location: Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super (). __init__ ( f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) View Source def format_message ( self ): return self . message show def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. CruftError class CruftError ( message ) The base exception for any error originating from the cruft project. View Source class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\" Ancestors (in MRO) click.exceptions.ClickException builtins.Exception builtins.BaseException Descendants cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound cruft.exceptions.CruftAlreadyPresent cruft.exceptions.InvalidCookiecutterRepository Class variables args exit_code Methods format_message def format_message ( self ) View Source def format_message ( self ): return self . message show def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidCookiecutterRepository class InvalidCookiecutterRepository ( cookiecutter_repo : str ) Raised when an invalid cookiecutter repository is provided. View Source class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo: str ): super (). __init__ ( f \"{cookiecutter_repo} is not a valid Cookiecutter git repository!\" ) self . cookiecutter_repo = cookiecutter_repo Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) View Source def format_message ( self ): return self . message show def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoCruftFound class NoCruftFound ( directory : Union [ str , pathlib . Path ] ) Raised when no .cruft.json state is found in the current directory. View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) View Source def format_message ( self ): return self . message show def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnableToFindCookiecutterTemplate class UnableToFindCookiecutterTemplate ( directory : Union [ str , pathlib . Path ] ) Raised when Cruft is unable to find a cookiecutter template. View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException Class variables args exit_code Methods format_message def format_message ( self ) View Source def format_message ( self ): return self . message show def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file ) with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/cruft/exceptions/#module-cruftexceptions","text":"Contains all custom exceptions raised by cruft. View Source \"\"\"Contains all custom exceptions raised by cruft.\"\"\" from pathlib import Path from typing import Union from click import ClickException class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\" class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory : Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super () . __init__ ( f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location : Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super () . __init__ ( f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo : str ): super () . __init__ ( f \"{cookiecutter_repo} is not a valid Cookiecutter git repository!\" ) self . cookiecutter_repo = cookiecutter_repo","title":"Module cruft.exceptions"},{"location":"reference/cruft/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/cruft/exceptions/#cruftalreadypresent","text":"class CruftAlreadyPresent ( file_location : Union [ str , pathlib . Path ] ) Raised when there is an attempt to create a new .cruft.json file but one already exists. View Source class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists.\"\"\" def __init__ ( self , file_location: Union [ str , Path ]): if not isinstance ( file_location , str ): file_location = str ( file_location ) super (). __init__ ( f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location","title":"CruftAlreadyPresent"},{"location":"reference/cruft/exceptions/#ancestors-in-mro","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message","text":"def format_message ( self ) View Source def format_message ( self ): return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show","text":"def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#crufterror","text":"class CruftError ( message ) The base exception for any error originating from the cruft project. View Source class CruftError ( ClickException ): \"\"\"The base exception for any error originating from the cruft project.\"\"\"","title":"CruftError"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_1","text":"click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#descendants","text":"cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound cruft.exceptions.CruftAlreadyPresent cruft.exceptions.InvalidCookiecutterRepository","title":"Descendants"},{"location":"reference/cruft/exceptions/#class-variables_1","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_1","text":"def format_message ( self ) View Source def format_message ( self ): return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_1","text":"def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#invalidcookiecutterrepository","text":"class InvalidCookiecutterRepository ( cookiecutter_repo : str ) Raised when an invalid cookiecutter repository is provided. View Source class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided.\"\"\" def __init__ ( self , cookiecutter_repo: str ): super (). __init__ ( f \"{cookiecutter_repo} is not a valid Cookiecutter git repository!\" ) self . cookiecutter_repo = cookiecutter_repo","title":"InvalidCookiecutterRepository"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_2","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_2","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_2","text":"def format_message ( self ) View Source def format_message ( self ): return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_2","text":"def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#nocruftfound","text":"class NoCruftFound ( directory : Union [ str , pathlib . Path ] ) Raised when no .cruft.json state is found in the current directory. View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory","title":"NoCruftFound"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_3","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_3","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_3","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_3","text":"def format_message ( self ) View Source def format_message ( self ): return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_3","text":"def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#unabletofindcookiecuttertemplate","text":"class UnableToFindCookiecutterTemplate ( directory : Union [ str , pathlib . Path ] ) Raised when Cruft is unable to find a cookiecutter template. View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template.\"\"\" def __init__ ( self , directory: Union [ str , Path ]): if not isinstance ( directory , str ): directory = str ( directory ) super (). __init__ ( f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory","title":"UnableToFindCookiecutterTemplate"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_4","text":"cruft.exceptions.CruftError click.exceptions.ClickException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_4","text":"args exit_code","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_4","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#format_message_4","text":"def format_message ( self ) View Source def format_message ( self ): return self . message","title":"format_message"},{"location":"reference/cruft/exceptions/#show_4","text":"def show ( self , file = None ) View Source def show ( self , file = None ): if file is None : file = get_text_stderr () echo ( \"Error: {}\" . format ( self . format_message ()), file = file )","title":"show"},{"location":"reference/cruft/exceptions/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"}]}